<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>anova_two_way — plot en R (webR)</title>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; margin: 22px; }
    .row { display:flex; gap:14px; flex-wrap:wrap; align-items:center; }
    button { padding:10px 14px; border-radius:10px; border:0; background:#0ea5e9; color:#fff; font-weight:700; cursor:pointer; }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    .card { border:1px solid #e6e6e6; border-radius:12px; padding:14px; background:#fff; }
    #plotWrap { border:1px solid #e6e6e6; border-radius:12px; padding:10px; margin-top:14px; background:#fff; }
    #plotSvg { width: 100%; overflow:auto; }
    pre { background:#111; color:#eee; padding:12px; border-radius:10px; overflow:auto; max-height:220px; }
    .muted{ color:#666; font-size:12px; }
  </style>
</head>
<body>

<h2 style="margin:0 0 6px 0;">ANOVA 2 factores — gráfico hecho en R (webR)</h2>
<div class="muted">El HTML solo muestra el SVG. El gráfico lo genera ggplot2 dentro de webR.</div>

<div class="row" style="margin-top:12px;">
  <div class="card">
    <button id="btnInit">1) Inicializar webR</button>
    <div id="webrMsg" class="muted" style="margin-top:8px;"></div>
  </div>

  <div class="card">
    <input type="file" id="fileInput" accept=".xlsx,.xls,.csv"/>
    <div id="fileMsg" class="muted" style="margin-top:8px;"></div>
  </div>

  <div class="card">
    <button id="btnRun" disabled>2) Generar gráfico en R</button>
    <div id="runMsg" class="muted" style="margin-top:8px;"></div>
  </div>
</div>

<div id="plotWrap">
  <div id="plotSvg" class="muted">Aquí aparecerá el SVG generado por R…</div>
</div>

<div class="card" style="margin-top:14px;">
  <div class="muted">Salida R (debug)</div>
  <pre id="rout">---</pre>
</div>

<script type="module">
  import { WebR } from "https://webr.r-wasm.org/latest/webr.mjs";

  let webR = null;
  let ready = false;
  let rawRows = [];

  const btnInit = document.getElementById("btnInit");
  const btnRun  = document.getElementById("btnRun");
  const webrMsg = document.getElementById("webrMsg");
  const fileMsg = document.getElementById("fileMsg");
  const runMsg  = document.getElementById("runMsg");
  const rout    = document.getElementById("rout");
  const plotSvg = document.getElementById("plotSvg");

  btnInit.addEventListener("click", async () => {
    try {
      webrMsg.textContent = "Inicializando webR...";
      webR = new WebR();
      await webR.init();
      ready = true;
      webrMsg.textContent = "✅ webR listo.";
      if (rawRows.length) btnRun.disabled = false;
    } catch (e) {
      webrMsg.textContent = "❌ " + e.message;
    }
  });

  document.getElementById("fileInput").addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    rawRows = [];
    btnRun.disabled = true;
    plotSvg.textContent = "Aquí aparecerá el SVG generado por R…";
    rout.textContent = "---";

    const ext = file.name.toLowerCase().split(".").pop();
    const reader = new FileReader();

    reader.onload = (evt) => {
      try {
        if (ext === "csv") {
          rawRows = csvToJsonAuto(evt.target.result);
        } else {
          const wb = XLSX.read(evt.target.result, { type: "binary" });
          const ws = wb.Sheets[wb.SheetNames[0]];
          rawRows = XLSX.utils.sheet_to_json(ws, { defval: "" });
        }
        if (!rawRows.length) throw new Error("Archivo vacío.");
        fileMsg.textContent = `✅ Cargado: ${file.name} | filas: ${rawRows.length}`;
        if (ready) btnRun.disabled = false;
      } catch (err) {
        fileMsg.textContent = "❌ " + err.message;
      }
    };

    if (ext === "csv") reader.readAsText(file);
    else reader.readAsBinaryString(file);
  });

  btnRun.addEventListener("click", async () => {
    try {
      if (!ready) throw new Error("Inicializa webR primero.");
      if (!rawRows.length) throw new Error("Carga un archivo primero.");

      runMsg.textContent = "Ejecutando R y generando SVG...";
      rout.textContent = "---";

      // Esperado (LONG) en este ejemplo:
      // Tratamiento, FactorB, Atributo, Variable
      // (si quieres WIDE, lo pivoteamos también, pero primero lo dejamos simple)
      const csv = toCSV(rawRows);

      const rcode = `
        # ---- leer datos ----
        df <- read.csv(text=${JSON.stringify(csv)}, stringsAsFactors=FALSE)

        # Normalizar nombres esperados
        # Requeridos: Tratamiento, FactorB, Atributo, Variable
        # Si tu CSV viene con otros nombres, los renombramos aquí.
        if(!("Tratamiento" %in% names(df))) stop("Falta columna: Tratamiento")
        if(!("FactorB" %in% names(df))) stop("Falta columna: FactorB")
        if(!("Atributo" %in% names(df))) stop("Falta columna: Atributo")
        if(!("Variable" %in% names(df))) stop("Falta columna: Variable")

        df$Tratamiento <- as.factor(as.character(df$Tratamiento))  # ✅ texto/categoría
        df$FactorB     <- as.factor(as.character(df$FactorB))      # ✅ texto/categoría
        df$Atributo    <- as.character(df$Atributo)
        df$Variable    <- suppressWarnings(as.numeric(df$Variable))

        df <- df[is.finite(df$Variable), ]
        if(nrow(df) < 4) stop("Muy pocos datos numéricos en Variable.")

        # Elegir atributo: el primero (puedes luego hacer selector)
        attr_sel <- unique(df$Atributo)[1]
        d2 <- df[df$Atributo == attr_sel, ]
        if(length(levels(d2$Tratamiento)) < 2 || length(levels(d2$FactorB)) < 2){
          stop("Se requieren ≥2 niveles en Tratamiento y FactorB para el atributo.")
        }

        # ---- stats (base R) ----
        m <- lm(Variable ~ Tratamiento * FactorB, data=d2)
        p_norm <- tryCatch(shapiro.test(residuals(m))$p.value, error=function(e) NA_real_)
        tab <- anova(m)

        # ---- plot (ggplot2) ----
        # webR normalmente incluye ggplot2, pero si falla, te lo mostrará en consola.
        suppressWarnings(library(ggplot2))

        # Tabla tipo "stats_cell" (base R)
        agg <- aggregate(Variable ~ Tratamiento + FactorB, d2, function(x){
          c(n=length(x), mean=mean(x), median=median(x), sd=sd(x),
            cv=100*sd(x)/mean(x), ymin=min(x), ymax=max(x))
        })
        # expandir columnas
        agg2 <- data.frame(agg[1:2], do.call(rbind, agg$Variable))
        names(agg2) <- c("Tratamiento","FactorB","n","mean","median","sd","cv","ymin","ymax")

        rng <- diff(range(d2$Variable, na.rm=TRUE)); if(!is.finite(rng) || rng==0) rng <- 1
        TOP_OFF <- 0.06*rng; BOT_OFF <- 0.06*rng; LET_OFF <- 0.12*rng

        agg2$y_top_median <- agg2$ymax + TOP_OFF*2
        agg2$y_top_mean   <- agg2$ymax + TOP_OFF
        agg2$y_bot_sd     <- agg2$ymin - BOT_OFF*2
        agg2$y_bot_cv     <- agg2$ymin - BOT_OFF
        agg2$y_bot_n      <- agg2$ymin

        # Texto subtítulo
        fmt <- function(x) ifelse(is.na(x), "NA", formatC(x, digits=3, format="f"))
        subtxt <- paste0("ANOVA base | Shapiro p=", fmt(p_norm))

        g <- ggplot(d2, aes(x=Tratamiento, y=Variable, fill=FactorB)) +
          geom_boxplot(alpha=0.85, width=0.72, outlier.colour="red",
                       position=position_dodge(width=0.8)) +
          stat_summary(fun=mean, geom="point", shape=21, size=3,
                       colour="black", fill="white",
                       position=position_dodge(width=0.8)) +
          geom_text(data=agg2, aes(y=y_top_median, label=round(median,2), group=FactorB),
                    position=position_dodge(width=0.8), size=3.8) +
          geom_text(data=agg2, aes(y=y_top_mean, label=round(mean,2), group=FactorB),
                    position=position_dodge(width=0.8), size=3.8) +
          geom_text(data=agg2, aes(y=y_bot_n, label=n, group=FactorB),
                    position=position_dodge(width=0.8), size=3.8) +
          geom_text(data=agg2, aes(y=y_bot_cv, label=round(cv,1), group=FactorB),
                    position=position_dodge(width=0.8), size=3.6) +
          geom_text(data=agg2, aes(y=y_bot_sd, label=round(sd,2), group=FactorB),
                    position=position_dodge(width=0.8), size=3.6) +
          labs(
            title="ANOVA de dos factores (webR): Tratamiento × Factor B",
            subtitle=subtxt,
            x="Tratamiento", y=attr_sel, fill="Factor B"
          ) +
          theme_minimal(base_size=13) +
          theme(
            axis.line.x=element_line(color="#111111", linewidth=0.8),
            axis.line.y=element_line(color="#111111", linewidth=0.8),
            axis.ticks=element_line(color="#111111", linewidth=0.6),
            axis.text=element_text(color="#111111"),
            axis.title=element_text(color="#111111"),
            panel.grid.major=element_line(color="gray88", linewidth=0.4),
            panel.grid.minor=element_blank()
          ) +
          coord_cartesian(clip="off")

        # ---- export SVG a FS virtual de webR ----
        svg("plot.svg", width=12, height=7)
        print(g)
        dev.off()

        cat("OK: plot.svg generado\\n")
      `;

      await webR.evalRVoid(rcode);
      const flushed = await webR.flush();
      const outText = flushed.map(x => x.data).join("");
      rout.textContent = outText;

      // Leer el SVG desde el FS de webR
      const bytes = webR.FS.readFile("plot.svg");
      const svgText = new TextDecoder("utf-8").decode(bytes);

      // Insertar SVG (100% generado por R)
      plotSvg.innerHTML = svgText;
      runMsg.textContent = "✅ Gráfico generado en R y renderizado como SVG.";
    } catch (e) {
      runMsg.textContent = "❌ " + e.message;
    }
  });

  // -------- CSV helpers (auto , ;) --------
  function detectDelimiter(text) {
    const lines = text.split(/\r?\n/).slice(0, 20).filter(l => l.trim().length);
    if (!lines.length) return ",";
    const score = (delim) => {
      const counts = lines.map(l => l.split(delim).length);
      const max = Math.max(...counts), min = Math.min(...counts);
      return (max >= 2 ? max : 0) - (max - min);
    };
    const cand = [",",";","\t","|"];
    let best = cand[0], bestScore = -Infinity;
    cand.forEach(d => { const s = score(d); if (s > bestScore) { bestScore=s; best=d; }});
    return best;
  }
  function csvToJsonAuto(text){ return csvToJson(text, detectDelimiter(text)); }
  function csvToJson(text, delim){
    const lines = text.split(/\r?\n/).filter(l => l.trim().length);
    const headers = lines[0].split(delim).map(h => h.trim());
    const out = [];
    for (let i=1; i<lines.length; i++){
      const parts = lines[i].split(delim);
      const row = {};
      headers.forEach((h,idx)=> row[h] = (parts[idx] ?? "").trim());
      out.push(row);
    }
    return out;
  }
  function toCSV(rows){
    const cols = Object.keys(rows[0]);
    const head = cols.join(",") + "\n";
    const body = rows.map(r => cols.map(c => csvEsc(String(r[c] ?? ""))).join(",")).join("\n");
    return head + body + "\n";
  }
  function csvEsc(s){
    if (s.includes(",") || s.includes('"') || s.includes("\n")) return `"${s.replace(/"/g,'""')}"`;
    return s;
  }
</script>

</body>
</html>
