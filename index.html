<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ANOVA 2 factores: Tratamiento × Factor B (HTML)</title>

<script src="https://cdn.plot.ly/plotly-2.30.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

<style>
  body { font-family: Arial, sans-serif; margin: 22px; color:#111; }
  .row { display:flex; gap:18px; flex-wrap: wrap; }
  .card { border:1px solid #e6e6e6; border-radius:12px; padding:14px; background:#fff; box-shadow: 0 2px 10px rgba(0,0,0,.04); }
  .card h3 { margin:0 0 10px 0; font-size:16px; }
  label { font-size: 12px; color:#333; }
  select, input, button { width: 340px; padding: 8px; border-radius:10px; border:1px solid #ddd; }
  button { cursor:pointer; width:auto; padding:10px 14px; border:0; background:#0ea5e9; color:#fff; font-weight:700; }
  button:hover{ filter:brightness(.95); }
  #plot { width: 100%; height: 720px; }
  .muted { color:#666; font-size:12px; }
  .warn { color:#b91c1c; font-weight:700; }
</style>
</head>

<body>

<h2 style="margin:0 0 6px 0;">ANOVA de dos factores: Tratamiento × Factor B (HTML)</h2>
<div class="muted">
  Sube Excel/CSV en formato <b>WIDE</b> (tanque, tratamiento, factorB, var1, var2, ...) o <b>LONG</b> (Tratamiento, FactorB, Atributo, Variable).
</div>

<div class="row" style="margin-top:14px;">
  <div class="card">
    <h3>1) Carga</h3>
    <input type="file" id="fileInput" accept=".xlsx,.xls,.csv" />
    <div id="fileMsg" class="muted" style="margin-top:8px;"></div>
  </div>

  <div class="card">
    <h3>2) Mapeo columnas</h3>

    <label>Columna Tratamiento (Factor A)</label><br/>
    <select id="colTrat"></select><br/><br/>

    <label>Columna Factor secundario (Factor B: tiempo, temperatura, condición, etc.)</label><br/>
    <select id="colFactorB"></select><br/><br/>

    <label>Modo de datos</label><br/>
    <select id="dataMode">
      <option value="wide">WIDE (var1, var2, ...)</option>
      <option value="long">LONG (Atributo + Variable ya vienen)</option>
    </select><br/><br/>

    <div id="longCols" style="display:none;">
      <label>Columna Atributo</label><br/>
      <select id="colAtrib"></select><br/><br/>

      <label>Columna Variable (numérica)</label><br/>
      <select id="colValue"></select><br/><br/>
    </div>

    <button id="btnBuild" disabled>Preparar dataset</button>
    <div id="prepMsg" class="muted" style="margin-top:8px;"></div>
  </div>

  <div class="card">
    <h3>3) Selección</h3>
    <label>Atributo a graficar</label><br/>
    <select id="attrSel"></select><br/><br/>

    <button id="btnPlot" disabled>Generar gráfico</button>
    <div id="plotMsg" class="muted" style="margin-top:8px;"></div>

    <div class="muted" style="margin-top:8px;">
      Requisito: ≥2 niveles en Tratamiento y en Factor B.
    </div>
  </div>
</div>

<div class="card" style="margin-top:16px;">
  <div id="plot"></div>
</div>

<script>
let raw = [];
let longDF = []; // {Tratamiento, FactorB, Atributo, Variable}

const fileMsg = document.getElementById("fileMsg");
const prepMsg = document.getElementById("prepMsg");
const plotMsg = document.getElementById("plotMsg");
const btnBuild = document.getElementById("btnBuild");
const btnPlot = document.getElementById("btnPlot");

const dataMode = document.getElementById("dataMode");
const longColsDiv = document.getElementById("longCols");

dataMode.addEventListener("change", () => {
  longColsDiv.style.display = dataMode.value === "long" ? "block" : "none";
});

function setSelectOptions(selectEl, cols) {
  selectEl.innerHTML = "";
  cols.forEach(c => {
    const opt = document.createElement("option");
    opt.value = c; opt.textContent = c;
    selectEl.appendChild(opt);
  });
}

document.getElementById("fileInput").addEventListener("change", (e) => {
  const file = e.target.files?.[0];
  if (!file) return;

  raw = [];
  longDF = [];
  btnBuild.disabled = true;
  btnPlot.disabled = true;
  document.getElementById("attrSel").innerHTML = "";
  Plotly.purge("plot");

  const ext = file.name.toLowerCase().split(".").pop();

  const reader = new FileReader();
  reader.onload = (evt) => {
    try {
      if (ext === "csv") {
        const text = evt.target.result;
        raw = csvToJson(text);
      } else {
        const wb = XLSX.read(evt.target.result, { type: "binary" });
        const ws = wb.Sheets[wb.SheetNames[0]];
        raw = XLSX.utils.sheet_to_json(ws, { defval: null });
      }
      if (!raw.length) throw new Error("Archivo vacío.");

      const cols = Object.keys(raw[0]);
      setSelectOptions(document.getElementById("colTrat"), cols);
      setSelectOptions(document.getElementById("colFactorB"), cols);
      setSelectOptions(document.getElementById("colAtrib"), cols);
      setSelectOptions(document.getElementById("colValue"), cols);

      fileMsg.innerHTML = `✅ Cargado: <b>${file.name}</b> | filas: ${raw.length} | columnas: ${cols.length}`;
      btnBuild.disabled = false;
    } catch (err) {
      fileMsg.innerHTML = `<span class="warn">Error:</span> ${err.message}`;
    }
  };

  if (ext === "csv") reader.readAsText(file);
  else reader.readAsBinaryString(file);
});

btnBuild.addEventListener("click", () => {
  try {
    prepMsg.textContent = "";
    plotMsg.textContent = "";
    btnPlot.disabled = true;
    longDF = [];

    const cTrat = document.getElementById("colTrat").value;
    const cFB   = document.getElementById("colFactorB").value;

    if (!cTrat || !cFB) throw new Error("Selecciona columnas Tratamiento (A) y Factor B.");

    if (dataMode.value === "wide") {
      const cols = Object.keys(raw[0]);
      const attrCols = cols.filter(c => c !== cTrat && c !== cFB);

      if (attrCols.length === 0) throw new Error("No hay columnas de variables (WIDE) para pivotear.");

      raw.forEach(r => {
        const trat = r[cTrat];
        const fb   = r[cFB];
        attrCols.forEach(a => {
          longDF.push({
            Tratamiento: trat,
            FactorB: fb,
            Atributo: a,
            Variable: toNum(r[a])
          });
        });
      });
    } else {
      const cAtrib = document.getElementById("colAtrib").value;
      const cVal   = document.getElementById("colValue").value;
      if (!cAtrib || !cVal) throw new Error("Selecciona columnas Atributo y Variable.");
      raw.forEach(r => {
        longDF.push({
          Tratamiento: r[cTrat],
          FactorB: r[cFB],
          Atributo: r[cAtrib],
          Variable: toNum(r[cVal])
        });
      });
    }

    longDF = longDF.filter(d =>
      d.Tratamiento != null && d.FactorB != null && d.Atributo != null && Number.isFinite(d.Variable)
    );

    if (!longDF.length) throw new Error("No quedaron filas válidas (revisa valores numéricos).");

    const attrs = [...new Set(longDF.map(d => String(d.Atributo)))].sort();
    setSelectOptions(document.getElementById("attrSel"), attrs);

    prepMsg.innerHTML = `✅ Dataset long listo | filas válidas: ${longDF.length} | atributos: ${attrs.length}`;
    btnPlot.disabled = false;
  } catch (err) {
    prepMsg.innerHTML = `<span class="warn">Error:</span> ${err.message}`;
  }
});

btnPlot.addEventListener("click", () => {
  try {
    plotMsg.textContent = "";
    Plotly.purge("plot");

    const attr = document.getElementById("attrSel").value;
    if (!attr) throw new Error("Selecciona un Atributo.");

    const data2 = longDF.filter(d => String(d.Atributo) === String(attr));

    const trats = [...new Set(data2.map(d => String(d.Tratamiento)))];
    const fbs   = [...new Set(data2.map(d => String(d.FactorB)))];
    if (trats.length < 2 || fbs.length < 2) {
      throw new Error("Se requieren ≥2 niveles en Tratamiento y Factor B para este atributo.");
    }

    const cellStats = computeCellStats(data2);

    const vals = data2.map(d => d.Variable);
    let rng = (Math.max(...vals) - Math.min(...vals));
    if (!isFinite(rng) || rng === 0) rng = Math.max(1, Math.abs(mean(vals))*0.1);

    const TOP_OFF = 0.06 * rng;
    const BOT_OFF = 0.06 * rng;

    cellStats.forEach(s => {
      s.y_top_median = s.y_max + TOP_OFF*2;
      s.y_top_mean   = s.y_max + TOP_OFF;
      s.y_bot_sd     = s.y_min - BOT_OFF*2;
      s.y_bot_cv     = s.y_min - BOT_OFF;
      s.y_bot_n      = s.y_min - BOT_OFF*0.0;
    });

    const y_low  = Math.min(...cellStats.map(s => s.y_min - BOT_OFF*2));
    const y_high = Math.max(...cellStats.map(s => s.y_max + TOP_OFF*3));

    const traces = buildBoxTraces(data2, fbs);
    const meanPts = buildMeanPoints(cellStats, fbs);
    const textTraces = buildTextTraces(cellStats);
    const leftLabels = buildLeftLabels(cellStats);

    const layout = {
      title: { text: `ANOVA de dos factores: Tratamiento × Factor B<br><span style="font-size:12px;">(Visual + descriptivos)</span>`, x: 0.5 },
      paper_bgcolor: "white",
      plot_bgcolor: "white",
      xaxis: { title: "Tratamiento (Factor A)", showline:true, linewidth:1, linecolor:"#111", tickcolor:"#111" },
      yaxis: { title: attr, range:[y_low, y_high], showline:true, linewidth:1, linecolor:"#111", tickcolor:"#111", gridcolor:"#eaeaea" },
      boxmode: "group",
      legend: { orientation: "v", x: 1.02, y: 1, title: {text: "Factor B"} },
      margin: { t: 90, r: 140, b: 60, l: 80 }
    };

    Plotly.newPlot("plot",
      [...traces, meanPts, ...textTraces, ...leftLabels],
      layout,
      {displayModeBar: true, responsive: true}
    );

    plotMsg.innerHTML = `✅ Gráfico generado para Atributo: <b>${attr}</b>`;
  } catch (err) {
    plotMsg.innerHTML = `<span class="warn">Error:</span> ${err.message}`;
  }
});

function buildBoxTraces(data2, fbs) {
  // Un trace por nivel del Factor B
  return fbs.map(fb => {
    const x = [];
    const y = [];
    data2.forEach(d => {
      if (String(d.FactorB) === String(fb)) {
        x.push(String(d.Tratamiento));
        y.push(d.Variable);
      }
    });
    return { type:"box", name:String(fb), x, y, boxpoints:false, marker:{opacity:0.85}, line:{width:1} };
  });
}

function buildMeanPoints(cellStats, fbs) {
  const x = cellStats.map(s => String(s.Tratamiento));
  const y = cellStats.map(s => s.mean);
  const text = cellStats.map(s => `mean=${round(s.mean,2)}<br>${s.Tratamiento} | ${s.FactorB}`);

  return {
    type: "scatter",
    mode: "markers",
    name: "mean",
    x, y,
    text, hoverinfo: "text",
    marker: {size: 8, symbol: "circle-open", color: "black", line: {width: 2}}
  };
}

function buildTextTraces(cellStats) {
  const layers = [];

  function mkLayer(yKey, labelFn, size) {
    return {
      type: "scatter",
      mode: "text",
      showlegend: false,
      x: cellStats.map(s => String(s.Tratamiento)),
      y: cellStats.map(s => s[yKey]),
      text: cellStats.map(s => labelFn(s)),
      textposition: "middle center",
      textfont: {size: size}
    };
  }

  layers.push(mkLayer("y_top_median", s => round(s.median,2), 12));
  layers.push(mkLayer("y_top_mean",   s => round(s.mean,2),   12));
  layers.push(mkLayer("y_bot_n",      s => String(s.n),       12));
  layers.push(mkLayer("y_bot_cv",     s => round(s.cv,1),     11));
  layers.push(mkLayer("y_bot_sd",     s => round(s.sd,2),     11));

  return layers;
}

function buildLeftLabels(cellStats) {
  const x0 = String(cellStats[0].Tratamiento);
  const yTopMed = Math.max(...cellStats.map(s => s.y_top_median));
  const yTopMean= Math.max(...cellStats.map(s => s.y_top_mean));
  const yBotN   = Math.min(...cellStats.map(s => s.y_bot_n));
  const yBotCV  = Math.min(...cellStats.map(s => s.y_bot_cv));
  const yBotSD  = Math.min(...cellStats.map(s => s.y_bot_sd));

  return [
    {type:"scatter", mode:"text", showlegend:false, x:[x0], y:[yTopMed], text:["median"], textfont:{size:11}},
    {type:"scatter", mode:"text", showlegend:false, x:[x0], y:[yTopMean],text:["mean"],   textfont:{size:11}},
    {type:"scatter", mode:"text", showlegend:false, x:[x0], y:[yBotN],   text:["n"],      textfont:{size:11}},
    {type:"scatter", mode:"text", showlegend:false, x:[x0], y:[yBotCV],  text:["cv"],     textfont:{size:11}},
    {type:"scatter", mode:"text", showlegend:false, x:[x0], y:[yBotSD],  text:["sd"],     textfont:{size:11}}
  ];
}

function computeCellStats(data2) {
  const g = groupBy(data2, d => `${d.Tratamiento}|${d.FactorB}`);
  const out = [];
  Object.entries(g).forEach(([key, arr]) => {
    const [trat, fb] = key.split("|");
    const v = arr.map(a => a.Variable).filter(Number.isFinite);
    const n = v.length;
    const m = mean(v);
    const med = median(v);
    const sd = std(v);
    const cv = (m !== 0 && isFinite(m)) ? (100*sd/m) : NaN;
    out.push({
      Tratamiento: trat,
      FactorB: fb,
      n, mean: m, median: med, sd, cv,
      y_min: Math.min(...v),
      y_max: Math.max(...v)
    });
  });
  return out;
}

function groupBy(arr, keyFn) {
  const obj = {};
  arr.forEach(x => {
    const k = keyFn(x);
    (obj[k] = obj[k] || []).push(x);
  });
  return obj;
}

function mean(a){ return a.reduce((s,x)=>s+x,0)/a.length; }
function median(a){
  const b = [...a].sort((x,y)=>x-y);
  const n = b.length;
  return n%2 ? b[(n-1)/2] : (b[n/2-1]+b[n/2])/2;
}
function std(a){
  if (a.length < 2) return 0;
  const m = mean(a);
  const v = a.reduce((s,x)=>s+(x-m)*(x-m),0)/(a.length-1);
  return Math.sqrt(v);
}
function round(x,d){
  if (!isFinite(x)) return "NA";
  const p = Math.pow(10,d);
  return (Math.round(x*p)/p).toFixed(d);
}
function toNum(x){
  if (x == null || x === "") return NaN;
  const v = Number(x);
  return Number.isFinite(v) ? v : NaN;
}

function csvToJson(text) {
  const lines = text.split(/\r?\n/).filter(l => l.trim().length);
  const headers = lines[0].split(/[,;|\t]/).map(h => h.trim());
  const out = [];
  for (let i=1;i<lines.length;i++){
    const parts = lines[i].split(/[,;|\t]/);
    const row = {};
    headers.forEach((h,idx)=> row[h] = parts[idx] ?? null);
    out.push(row);
  }
  return out;
}
</script>

</body>
</html>
