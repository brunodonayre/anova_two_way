<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>anova_two_way — plot en R (webR)</title>

  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>

  <style>
    body { font-family: Arial, sans-serif; margin: 22px; color:#111; }
    .row { display:flex; gap:14px; flex-wrap:wrap; align-items:flex-start; }
    .card { border:1px solid #e6e6e6; border-radius:12px; padding:14px; background:#fff; }
    button { padding:10px 14px; border-radius:10px; border:0; background:#0ea5e9; color:#fff; font-weight:700; cursor:pointer; }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    select, input { padding:8px; border-radius:10px; border:1px solid #ddd; width: 320px; }
    label{ font-size:12px; color:#333; }
    .muted{ color:#666; font-size:12px; }
    .warn { color:#b91c1c; font-weight:700; }
    .ok { color:#15803d; font-weight:700; }
    #plotWrap { border:1px solid #e6e6e6; border-radius:12px; padding:10px; margin-top:14px; background:#fff; }
    #plotSvg { width: 100%; overflow:auto; }
    pre { background:#111; color:#eee; padding:12px; border-radius:10px; overflow:auto; max-height:240px; }
  </style>
</head>
<body>

<h2 style="margin:0 0 6px 0;">ANOVA 2 factores — gráfico hecho en R (webR)</h2>
<div class="muted">Ahora el app no exige nombres fijos: tú mapeas columnas y R renombra internamente.</div>

<div class="row" style="margin-top:12px;">
  <div class="card">
    <button id="btnInit">1) Inicializar webR</button>
    <div id="webrMsg" class="muted" style="margin-top:8px;"></div>
  </div>

  <div class="card">
    <input type="file" id="fileInput" accept=".xlsx,.xls,.csv"/>
    <div id="fileMsg" class="muted" style="margin-top:8px;"></div>
  </div>

  <div class="card">
    <div class="muted" style="margin-bottom:8px;"><b>2) Mapeo de columnas</b></div>

    <label>Tratamiento (Factor A)</label><br/>
    <select id="colTrat"></select><br/><br/>

    <label>Factor B (tiempo / temperatura / días / etc.)</label><br/>
    <select id="colFB"></select><br/><br/>

    <label>Atributo (ej. “% Consumo”, “Peso Seco (g)”, etc.)</label><br/>
    <select id="colAtrib"></select><br/><br/>

    <label>Variable numérica</label><br/>
    <select id="colVal"></select><br/><br/>

    <button id="btnRun" disabled>3) Generar gráfico en R</button>
    <div id="runMsg" class="muted" style="margin-top:8px;"></div>
  </div>
</div>

<div id="plotWrap">
  <div id="plotSvg" class="muted">Aquí aparecerá el SVG generado por R…</div>
</div>

<div class="card" style="margin-top:14px;">
  <div class="muted">Salida R (debug)</div>
  <pre id="rout">---</pre>
</div>

<script type="module">
  import { WebR } from "https://webr.r-wasm.org/latest/webr.mjs";

  let webR = null;
  let ready = false;
  let rawRows = [];
  let cols = [];

  const btnInit = document.getElementById("btnInit");
  const btnRun  = document.getElementById("btnRun");
  const webrMsg = document.getElementById("webrMsg");
  const fileMsg = document.getElementById("fileMsg");
  const runMsg  = document.getElementById("runMsg");
  const rout    = document.getElementById("rout");
  const plotSvg = document.getElementById("plotSvg");

  const colTrat = document.getElementById("colTrat");
  const colFB   = document.getElementById("colFB");
  const colAtrib= document.getElementById("colAtrib");
  const colVal  = document.getElementById("colVal");

  function setOptions(sel, arr){
    sel.innerHTML = "";
    arr.forEach(c => {
      const o = document.createElement("option");
      o.value = c; o.textContent = c;
      sel.appendChild(o);
    });
  }

  btnInit.addEventListener("click", async () => {
    try {
      webrMsg.textContent = "Inicializando webR...";
      webR = new WebR();
      await webR.init();
      ready = true;
      webrMsg.innerHTML = `<span class="ok">✅ webR listo.</span>`;
      if (rawRows.length) btnRun.disabled = false;
    } catch (e) {
      webrMsg.innerHTML = `<span class="warn">❌</span> ${e.message}`;
    }
  });

  document.getElementById("fileInput").addEventListener("change", (e) => {
    const file = e.target.files?.[0];
    if (!file) return;

    rawRows = [];
    cols = [];
    btnRun.disabled = true;
    plotSvg.textContent = "Aquí aparecerá el SVG generado por R…";
    rout.textContent = "---";
    runMsg.textContent = "";

    const ext = file.name.toLowerCase().split(".").pop();
    const reader = new FileReader();

    reader.onload = (evt) => {
      try {
        if (ext === "csv") {
          rawRows = csvToJsonAuto(evt.target.result);
        } else {
          const wb = XLSX.read(evt.target.result, { type: "binary" });
          const ws = wb.Sheets[wb.SheetNames[0]];
          rawRows = XLSX.utils.sheet_to_json(ws, { defval: "" });
        }
        if (!rawRows.length) throw new Error("Archivo vacío.");
        cols = Object.keys(rawRows[0]);
        if (!cols.length) throw new Error("No se detectaron columnas.");

        setOptions(colTrat, cols);
        setOptions(colFB, cols);
        setOptions(colAtrib, cols);
        setOptions(colVal, cols);

        // Heurística: autoselección si existe "tratamiento"
        autoPick(colTrat, ["tratamiento","treatment"]);
        autoPick(colFB,   ["tiempo","time","temperatura","temp","dias","día","day","semana","week"]);
        autoPick(colAtrib,["atributo","attr","variable_name","metric"]);
        autoPick(colVal,  ["valor","value","variable","y"]);

        fileMsg.innerHTML = `<span class="ok">✅</span> Cargado: <b>${file.name}</b> | filas: ${rawRows.length} | cols: ${cols.length}`;
        if (ready) btnRun.disabled = false;
      } catch (err) {
        fileMsg.innerHTML = `<span class="warn">❌</span> ${err.message}`;
      }
    };

    if (ext === "csv") reader.readAsText(file);
    else reader.readAsBinaryString(file);
  });

  function autoPick(selectEl, candidates){
    const lower = cols.map(c => c.toLowerCase());
    for (const cand of candidates){
      const idx = lower.findIndex(x => x === cand || x.includes(cand));
      if (idx >= 0) { selectEl.value = cols[idx]; return; }
    }
  }

  btnRun.addEventListener("click", async () => {
    try {
      if (!ready) throw new Error("Inicializa webR primero.");
      if (!rawRows.length) throw new Error("Carga un archivo primero.");

      const cTrat = colTrat.value;
      const cFB   = colFB.value;
      const cA    = colAtrib.value;
      const cV    = colVal.value;

      if (!cTrat || !cFB || !cA || !cV) throw new Error("Completa el mapeo de columnas.");

      runMsg.textContent = "Ejecutando R y generando SVG...";
      rout.textContent = "---";

      // Construir un CSV “normalizado” para R con nombres estándar
      const normalized = rawRows.map(r => ({
        Tratamiento: r[cTrat],
        FactorB: r[cFB],
        Atributo: r[cA],
        Variable: r[cV]
      }));

      const csv = toCSV(normalized);

      const rcode = `
        df <- read.csv(text=${JSON.stringify(csv)}, stringsAsFactors=FALSE)

        df$Tratamiento <- as.factor(as.character(df$Tratamiento)) # ✅ categorías aunque sean números
        df$FactorB     <- as.factor(as.character(df$FactorB))
        df$Atributo    <- as.character(df$Atributo)
        df$Variable    <- suppressWarnings(as.numeric(as.character(df$Variable)))

        df <- df[is.finite(df$Variable) & df$Tratamiento!="" & df$FactorB!="" & df$Atributo!="", ]
        if(nrow(df) < 4) stop("Muy pocos datos válidos en Variable (numérica).")

        attr_sel <- unique(df$Atributo)[1]
        d2 <- df[df$Atributo == attr_sel, ]

        if(length(levels(d2$Tratamiento)) < 2 || length(levels(d2$FactorB)) < 2){
          stop("Se requieren ≥2 niveles en Tratamiento y FactorB para el atributo seleccionado.")
        }

        suppressWarnings(library(ggplot2))

        # Modelo
        m <- lm(Variable ~ Tratamiento * FactorB, data=d2)
        p_norm <- tryCatch(shapiro.test(residuals(m))$p.value, error=function(e) NA_real_)

        # stats por celda
        agg <- aggregate(Variable ~ Tratamiento + FactorB, d2, function(x){
          c(n=length(x), mean=mean(x), median=median(x), sd=sd(x),
            cv=100*sd(x)/mean(x), ymin=min(x), ymax=max(x))
        })
        agg2 <- data.frame(agg[1:2], do.call(rbind, agg$Variable))
        names(agg2) <- c("Tratamiento","FactorB","n","mean","median","sd","cv","ymin","ymax")

        rng <- diff(range(d2$Variable, na.rm=TRUE)); if(!is.finite(rng) || rng==0) rng <- 1
        TOP_OFF <- 0.06*rng; BOT_OFF <- 0.06*rng

        agg2$y_top_median <- agg2$ymax + TOP_OFF*2
        agg2$y_top_mean   <- agg2$ymax + TOP_OFF
        agg2$y_bot_sd     <- agg2$ymin - BOT_OFF*2
        agg2$y_bot_cv     <- agg2$ymin - BOT_OFF
        agg2$y_bot_n      <- agg2$ymin

        fmt <- function(x) ifelse(is.na(x), "NA", formatC(x, digits=3, format="f"))
        subtxt <- paste0("ANOVA base | Shapiro p=", fmt(p_norm))

        g <- ggplot(d2, aes(x=Tratamiento, y=Variable, fill=FactorB)) +
          geom_boxplot(alpha=0.85, width=0.72, outlier.colour="red",
                       position=position_dodge(width=0.8)) +
          stat_summary(fun=mean, geom="point", shape=21, size=3,
                       colour="black", fill="white",
                       position=position_dodge(width=0.8)) +
          geom_text(data=agg2, aes(y=y_top_median, label=round(median,2), group=FactorB),
                    position=position_dodge(width=0.8), size=3.8) +
          geom_text(data=agg2, aes(y=y_top_mean, label=round(mean,2), group=FactorB),
                    position=position_dodge(width=0.8), size=3.8) +
          geom_text(data=agg2, aes(y=y_bot_n, label=n, group=FactorB),
                    position=position_dodge(width=0.8), size=3.8) +
          geom_text(data=agg2, aes(y=y_bot_cv, label=round(cv,1), group=FactorB),
                    position=position_dodge(width=0.8), size=3.6) +
          geom_text(data=agg2, aes(y=y_bot_sd, label=round(sd,2), group=FactorB),
                    position=position_dodge(width=0.8), size=3.6) +
          labs(
            title="ANOVA de dos factores (webR): Tratamiento × Factor B",
            subtitle=subtxt,
            x="Tratamiento", y=attr_sel, fill="Factor B"
          ) +
          theme_minimal(base_size=13) +
          theme(
            axis.line.x=element_line(color="#111111", linewidth=0.8),
            axis.line.y=element_line(color="#111111", linewidth=0.8),
            axis.ticks=element_line(color="#111111", linewidth=0.6),
            axis.text=element_text(color="#111111"),
            axis.title=element_text(color="#111111"),
            panel.grid.major=element_line(color="gray88", linewidth=0.4),
            panel.grid.minor=element_blank()
          ) +
          coord_cartesian(clip="off")

        svg("plot.svg", width=12, height=7)
        print(g)
        dev.off()

        cat("OK: plot.svg generado\\n")
        cat("Atributo usado: ", attr_sel, "\\n", sep="")
      `;

      await webR.evalRVoid(rcode);
      const flushed = await webR.flush();
      rout.textContent = flushed.map(x => x.data).join("");

      const bytes = webR.FS.readFile("plot.svg");
      const svgText = new TextDecoder("utf-8").decode(bytes);
      plotSvg.innerHTML = svgText;

      runMsg.innerHTML = `<span class="ok">✅</span> Gráfico generado en R y renderizado como SVG.`;
    } catch (e) {
      runMsg.innerHTML = `<span class="warn">❌</span> ${e.message}`;
    }
  });

  // -------- CSV helpers (auto , ;) --------
  function detectDelimiter(text) {
    const lines = text.split(/\r?\n/).slice(0, 20).filter(l => l.trim().length);
    if (!lines.length) return ",";
    const score = (delim) => {
      const counts = lines.map(l => l.split(delim).length);
      const max = Math.max(...counts), min = Math.min(...counts);
      return (max >= 2 ? max : 0) - (max - min);
    };
    const cand = [",",";","\t","|"];
    let best = cand[0], bestScore = -Infinity;
    cand.forEach(d => { const s = score(d); if (s > bestScore) { bestScore=s; best=d; }});
    return best;
  }
  function csvToJsonAuto(text){ return csvToJson(text, detectDelimiter(text)); }
  function csvToJson(text, delim){
    const lines = text.split(/\r?\n/).filter(l => l.trim().length);
    const headers = lines[0].split(delim).map(h => h.trim());
    const out = [];
    for (let i=1; i<lines.length; i++){
      const parts = lines[i].split(delim);
      const row = {};
      headers.forEach((h,idx)=> row[h] = (parts[idx] ?? "").trim());
      out.push(row);
    }
    return out;
  }
  function toCSV(rows){
    const cols = Object.keys(rows[0]);
    const head = cols.join(",") + "\n";
    const body = rows.map(r => cols.map(c => csvEsc(String(r[c] ?? ""))).join(",")).join("\n");
    return head + body + "\n";
  }
  function csvEsc(s){
    if (s.includes(",") || s.includes('"') || s.includes("\n")) return `"${s.replace(/"/g,'""')}"`;
    return s;
  }
</script>

</body>
</html>
